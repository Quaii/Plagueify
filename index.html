<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Plagueify — Refresh Token</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="color-scheme" content="dark" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root{
    color-scheme:dark;
    --bg:#0b0b0c; --ink:#e8e8ea; --line:#2b2f36;
    --blue1:#6da5ff; --blue2:#3a6df5; --blue3:#4a82ff;
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    background:var(--bg); color:var(--ink);
    font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overflow:hidden; cursor:none; /* we draw our own */
  }

  /* Frosted-glass + particle canvas (never intercepts clicks) */
  #bg{position:fixed; inset:0; width:100%; height:100%; display:block; z-index:0; pointer-events:none;}

  /* Fixed decorative overlays stacked above canvas, below stage */
  .fxLayer{position:fixed; inset:0; z-index:0; pointer-events:none}
  /* Disable lighting overlays to remove background glow/“shaved” look */
  .gridLayer, .bloomLayer { display: none !important; }
  .gridLayer{
    opacity:.10;
    mix-blend-mode:overlay;
    background-image:
      repeating-linear-gradient(0deg, rgba(100,150,255,.12), rgba(100,150,255,.12) 1px, transparent 1px, transparent 24px),
      repeating-linear-gradient(90deg, rgba(100,150,255,.12), rgba(100,150,255,.12) 1px, transparent 1px, transparent 24px);
  }
  .bloomLayer{
    opacity:.22;
    mix-blend-mode:screen;
    filter:blur(44px);
    background:
      radial-gradient(40% 40% at 28% 32%, rgba(109,165,255,.28), rgba(109,165,255,0) 60%),
      radial-gradient(46% 46% at 72% 68%, rgba(58,109,245,.22), rgba(58,109,245,0) 62%),
      radial-gradient(30% 30% at 50% 50%, rgba(74,130,255,.18), rgba(74,130,255,0) 65%);
  }
  .grainLayer{
    opacity:.1;
    mix-blend-mode:soft-light;
    background-image: radial-gradient(rgba(255,255,255,.12) 0.5px, transparent 0.6px);
    background-size: 3px 3px;
    background-position: 0 0;
  }

  .stage{position:relative; z-index:1; height:100%; display:grid; place-items:center; padding:24px; overflow:visible;}
  .container{width:min(820px,92vw); opacity:0; transform:translateY(8px) scale(.985)}
  .in{animation:fadeIn .7s cubic-bezier(.2,.75,.2,1) .05s forwards}
  @keyframes fadeIn{to{opacity:1; transform:translateY(0) scale(1)}}

  /* Title */
  .title{
    font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    font-weight:800; letter-spacing:.2px;
    font-size:clamp(48px,10vw,98px);
    line-height:1.05; user-select:none; text-align:center;
    margin:0 0 36px 0; white-space:nowrap; overflow:visible;
    text-shadow:0 0 10px rgba(90,140,255,.18);
    overflow:visible;
  }
  .titleRow{display:inline-flex; align-items:baseline; gap:0; overflow:visible;}
  .blueGrad{display:inline-block; padding-bottom:.08em;background:linear-gradient(180deg,var(--blue1) 0%,var(--blue3) 50%,var(--blue2) 100%);-webkit-background-clip:text; background-clip:text; color:transparent;filter:drop-shadow(0 0 8px rgba(90,140,255,.18));}

  /* Suffix lane — removed left margin so it's tight after the "E" */
  .suffixLane{ position:relative; display:inline-block; vertical-align:baseline; min-width:10px; margin-left:0; }
  .suffixText{ color:#fff; letter-spacing:0; display:inline-block; position:relative; white-space:nowrap; }
  .caret{ position:absolute; left:0; top:0; display:block; width:0.055em; height:0.9em; background:#fff; }
  @keyframes blink{0%,45%{opacity:1}55%,100%{opacity:.18}}
  .blink{animation:blink 950ms step-end infinite}
  @keyframes jiggle{0%{transform:translateY(0)}50%{transform:translateY(-1px)}100%{transform:translateY(0)}}

  /* Token UI */
  .block{width:min(700px,86vw); margin:0 auto}
  .label{font-weight:700; margin:0 0 8px 6px;}
  .token{
    width:100%; padding:12px 14px; background:#121317cc; color:var(--ink);
    border:1px solid var(--line); border-radius:0;
    font-family:ui-monospace,Menlo,Consolas,monospace; font-size:.95rem;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    outline:none; backdrop-filter:blur(2px);
    transition:border-color .18s ease, transform .18s ease;
  }
  .token:focus{border-color:#3c68ff; transform:translateY(-1px)}

  .controls{text-align:center; margin-top:16px}
  .btn{
    appearance:none; border:1px solid var(--line); background:#1a1c21; color:var(--ink);
    padding:12px 18px; border-radius:0; font-weight:700; letter-spacing:.2px;
    transition:transform .12s, border-color .2s, box-shadow .2s, background .2s;
    box-shadow:0 12px 28px rgba(0,0,0,.28);
  }
  .btn:hover{ transform:translateY(-1px); border-color:#3a4050; background:#1f2228; box-shadow:0 16px 34px rgba(0,0,0,.36) }
  .hero{display:flex; flex-direction:column; align-items:center; gap:28px}
  .btn-cta{ padding:14px 22px; margin-top:-10px; } /* move CTA up by 10px */

  /* Focus visibility for keyboard users */
  .btn:focus-visible{
    outline:2px solid #4a82ff; outline-offset:2px; border-color:#4a82ff;
    box-shadow:0 0 0 4px rgba(74,130,255,.22), 0 12px 28px rgba(0,0,0,.28);
  }
  .token:focus-visible{
    outline:2px solid #4a82ff; outline-offset:2px; border-color:#3c68ff;
  }
  /* Ensure OS cursor never shows on interactives */
  a, button, [role="button"], input, textarea, select, .btn, .token { cursor:none; }

  .hide{display:none !important}
  .muted{opacity:.72; font-size:.95rem; text-align:center; margin-top:10px}
  .ok{color:#9ae6a0} .err{color:#ff8c8c}

  /* Custom cursor — stronger glow ring + glow dot */
  .cursorRing{position:fixed; left:50%; top:50%; width:10px; height:10px; border-radius:50%; pointer-events:none; z-index:9999; border:none; background:transparent; box-shadow:0 0 30px rgba(90,140,255,0.85), 0 0 60px rgba(90,140,255,0.75), 0 0 90px rgba(90,140,255,0.65), 0 0 120px rgba(90,140,255,0.5); transform:translate(-50%,-50%);}
  .cursorDot{position:fixed; left:50%; top:50%; width:6px; height:6px; border-radius:50%; pointer-events:none; z-index:9999; background:rgba(200,215,255,1); box-shadow:0 0 20px rgba(90,140,255,1), 0 0 40px rgba(90,140,255,0.85), 0 0 80px rgba(90,140,255,0.7); transform:translate(-50%,-50%);}

  /* Respect reduced motion: hide overlays + custom cursor */
  @media (prefers-reduced-motion: reduce){
    .gridLayer, .bloomLayer, .grainLayer{display:none !important}
    .blink{animation:none}
    .cursorRing, .cursorDot{display:none !important}
  }

  /* Hide cursor on coarse pointers (touch devices) */
  @media (pointer: coarse){
    .cursorRing, .cursorDot{display:none !important}
  }
</style>
</head>
<body>
  <!-- Particle canvas -->
  <canvas id="bg" aria-hidden="true"></canvas>

  <!-- Decorative layers -->
  <div class="fxLayer gridLayer" aria-hidden="true"></div>
  <div class="fxLayer bloomLayer" aria-hidden="true"></div>
  <div class="fxLayer grainLayer" aria-hidden="true"></div>

  <!-- Custom glow cursor -->
  <div class="cursorRing" id="ring"></div>
  <div class="cursorDot" id="dot"></div>

  <div class="stage">
    <div class="container" id="container">
      <!-- Screen A -->
      <section id="screenA" class="hero">
        <h1 class="title" aria-live="polite">
          <span class="titleRow">
            <span class="blueGrad">Plague</span>
            <span class="suffixLane"><span id="suffix" class="suffixText"></span><span id="caret" class="caret blink"></span></span>
          </span>
        </h1>
        <button class="btn btn-cta" id="btn-login">Sign in to Spotify</button>
        <div id="statusA" class="muted"></div>
      </section>

      <!-- Screen B -->
      <section id="screenB" class="hide">
        <h1 class="title">
          <span class="titleRow"><span class="blueGrad">Plague</span><span class="suffixText">ify</span></span>
        </h1>
        <div class="block">
          <p class="label">Your Token</p>
          <input id="tokenBox" class="token" type="text" readonly />
          <div class="controls"><button class="btn" id="btn-copy">Manual Copy</button></div>
          <div id="statusB" class="muted"></div>
        </div>
      </section>
    </div>
  </div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('container').classList.add('in');

  /* ================= Frosted glass + floating particles (no lightning) ================= */
  (function frosted(){
    const c = document.getElementById('bg');
    const ctx = c.getContext('2d');
    const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
    let w,h,dpr;
    let dropsBack=[], dropsMid=[], dropsFront=[], heroOrbs=[];
    let lastT = performance.now();
    // Parallax tracking
    let tpx = 0, tpy = 0, ppx = 0, ppy = 0;
    function onPointer(e){
      const p = e.touches? e.touches[0]: e;
      const nx = (p.clientX / w) - 0.5;
      const ny = (p.clientY / h) - 0.5;
      tpx = nx; tpy = ny;
    }
    if (!prefersReduced){
      addEventListener('pointermove', onPointer, {passive:true});
      addEventListener('touchmove', onPointer, {passive:true});
    }

    function resize(){
      w = innerWidth; h = innerHeight; dpr = Math.min(2, devicePixelRatio||1);
      c.style.width = w+'px'; c.style.height = h+'px';
      c.width = (w*dpr)|0; c.height = (h*dpr)|0;
      ctx.setTransform(dpr,0,0,dpr,0,0);

      // base population from area
      const baseCount = Math.floor((w*h)/20000);

      // double particle amounts (locked from previous change)
      const backCount = Math.max(0, Math.floor(baseCount*0.40) * 2);
      const midCount  = Math.max(0, Math.floor(baseCount*0.38) * 2);
      const frontCount= Math.max(0, Math.floor(baseCount*0.22) * 2);
      const heroCount = 0;

      const MAX_TOTAL = 1400; // safety cap for ultra-wide
      const total = backCount+midCount+frontCount+heroCount;
      const scale = total>MAX_TOTAL ? MAX_TOTAL/total : 1;

      function fill(count, kind){
        return new Array(Math.floor(count*scale)).fill(0).map(()=>spawn(kind));
      }
      dropsBack = fill(backCount, 'back');
      dropsMid  = fill(midCount,  'mid');
      dropsFront= fill(frontCount,'front');
      heroOrbs  = fill(heroCount, 'hero');
    }

    function spawn(kind){
      const layer = kind;
      // slightly larger particle radii everywhere (~+20%)
      let r, vy, sway, alpha;
      if (layer==='back'){
        r = (0.6 + Math.random()*0.8) * 1.2;
        vy = 0.6 + Math.random()*1.1;
        sway = (Math.random()-.5)*0.28;
        alpha = 0.14 + Math.random()*0.18;
      } else if (layer==='mid'){
        r = (0.8 + Math.random()*1.2) * 1.2;
        vy = 0.3 + Math.random()*0.8;
        sway = (Math.random()-.5)*0.25;
        alpha = 0.14 + Math.random()*0.22;
      } else if (layer==='front'){
        r = (1.2 + Math.random()*1.4) * 1.2;
        vy = 0.18 + Math.random()*0.45;
        sway = (Math.random()-.5)*0.22;
        alpha = 0.12 + Math.random()*0.18;
      } else { // hero (unused)
        r = (6 + Math.random()*10) * 1.2;
        vy = 0.05 + Math.random()*0.12;
        sway = (Math.random()-.5)*0.18;
        alpha = 0.10 + Math.random()*0.14;
      }
      const twinkle = false; // disable flash to remove any "lightning" feel
      return {
        x: Math.random()*w, y: Math.random()*h,
        r, vy, sway,
        hue: 215 + Math.random()*18,
        alpha,
        twinkle,
        twFreq: 0.6 + Math.random()*0.8,
        twPhase: Math.random()*Math.PI*2,
        layer
      };
    }

    function drawGlass(){
      ctx.fillStyle = '#0b0b0c';
      ctx.fillRect(0,0,w,h);
    }

    function stepAndDrawSet(set, t){
      for (const d of set){
        d.y += d.vy; d.x += d.sway;
        if (d.y - d.r > h+10) { d.y = -10; d.x = Math.random()*w; }
        const a = d.alpha; // no twinkle
        ctx.shadowColor = `hsla(${d.hue}, 80%, 60%, ${a})`;
        ctx.fillStyle   = `hsla(${d.hue}, 80%, 60%, ${a*0.65})`;
        ctx.shadowBlur = d.layer==='front' ? 12 : (d.layer==='mid' ? 9 : 7);
        ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, Math.PI*2); ctx.fill();
      }
    }

    function draw(now){
      const dt = Math.min(100, now - lastT); // clamp
      lastT = now;
      const t = now/1000;
      // Ease parallax
      ppx += (tpx - ppx) * 0.06;
      ppy += (tpy - ppy) * 0.06;
      drawGlass();
      ctx.globalCompositeOperation = 'screen';
      ctx.save(); ctx.translate(ppx*12, ppy*12); stepAndDrawSet(dropsBack, t); ctx.restore();
      ctx.save(); ctx.translate(ppx*8,  ppy*8 ); stepAndDrawSet(dropsMid,  t); ctx.restore();
      ctx.save(); ctx.translate(ppx*5,  ppy*5 ); stepAndDrawSet(dropsFront,t); ctx.restore();
      ctx.shadowBlur = 0;
      ctx.globalCompositeOperation = 'source-over';
      if (!prefersReduced) requestAnimationFrame(draw);
    }

    resize(); addEventListener('resize', resize);
    if (prefersReduced){
      drawGlass();
    } else {
      requestAnimationFrame(draw);
    }
  })();

  /* ================= Precise glow cursor — ring + dot ================= */
  (function cursorGlow(){
    const ring = document.getElementById('ring');
    const dot  = document.getElementById('dot');
    const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
    const isCoarse = matchMedia('(pointer: coarse)').matches;
    if (prefersReduced || isCoarse){ ring.style.display='none'; dot.style.display='none'; return; }

    let rx = innerWidth/2, ry = innerHeight/2, tx = rx, ty = ry;
    let scale = 1, targetScale = 1;
    let throttleFlip = false;
    const heavy = (innerWidth*innerHeight*(window.devicePixelRatio||1)) > 5_000_000;

    function move(e){ const t = e.touches?e.touches[0]:e; tx=t.clientX; ty=t.clientY; }
    addEventListener('pointermove', move, {passive:true});

    function isInteractiveAt(x,y){
      const el = document.elementFromPoint(x,y);
      if (!el) return false;
      const sel = 'button, a, [role="button"], input, textarea, select, .btn';
      return el.closest(sel) != null;
    }

    (function tick(){
      if (heavy){ throttleFlip = !throttleFlip; if (throttleFlip){ requestAnimationFrame(tick); return; } }
      rx += (tx - rx) * 0.18; ry += (ty - ry) * 0.18;
      const overInteractive = isInteractiveAt(tx,ty);
      targetScale = overInteractive ? 1.12 : 1.0;
      scale += (targetScale - scale) * 0.2;

      const x = rx+'px', y = ry+'px', t = 'translate(-50%,-50%) scale(' + scale.toFixed(3) + ')';
      ring.style.left = x; ring.style.top = y; ring.style.transform = t;
      dot.style.left  = x; dot.style.top  = y; dot.style.transform  = t;

      /* Stronger glow on hover and idle */
      ring.style.boxShadow = overInteractive
        ? '0 0 40px rgba(90,140,255,0.95), 0 0 80px rgba(90,140,255,0.85), 0 0 120px rgba(90,140,255,0.7)'
        : '0 0 30px rgba(90,140,255,0.85), 0 0 60px rgba(90,140,255,0.75), 0 0 90px rgba(90,140,255,0.65)';

      dot.style.boxShadow = overInteractive
        ? '0 0 25px rgba(90,140,255,1), 0 0 50px rgba(90,140,255,0.9), 0 0 100px rgba(90,140,255,0.8)'
        : '0 0 20px rgba(90,140,255,1), 0 0 40px rgba(90,140,255,0.85), 0 0 80px rgba(90,140,255,0.7)';

      requestAnimationFrame(tick);
    })();
  })();

  /* ================= Typing (suffix only, anchored, smooth, loop) ================= */
  (function typing(){
    const suffixLane = document.querySelector('.suffixLane');
    const suffix = document.getElementById('suffix');
    const caret = document.getElementById('caret');
    const titleEl = document.querySelector('h1.title');
    const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Measure max width using an offscreen span so center stays steady
    const measure = (text)=>{
      const s = document.createElement('span');
      s.style.visibility='hidden'; s.style.position='absolute'; s.style.whiteSpace='nowrap';
      s.className = 'suffixText';
      s.textContent = text;
      document.body.appendChild(s);
      const w = s.getBoundingClientRect().width;
      document.body.removeChild(s);
      return w;
    };
    const MAX_SUFFIX = 'cheat.cc'; // lowercase 'c' per spec
    suffixLane.style.minWidth = Math.ceil(measure(MAX_SUFFIX)) + 'px';

    const sleep = ms => new Promise(r=>setTimeout(r, ms));

    function positionCaret(){
      const w = suffix.offsetWidth || 0;
      caret.style.left = (w + 6) + 'px';
    }

    async function type(text, cps){ // RAF/time-based stepper
      const start = performance.now(); let i = 0;
      return new Promise(resolve=>{
        function tick(){
          const elapsed = (performance.now()-start)/1000;
          const target = Math.floor(elapsed*cps);
          const next = Math.min(target, text.length);
          if (next > i){
            i = next;
            suffix.textContent = text.slice(0,i);
            positionCaret();
            caret.style.animation='jiggle 120ms ease-out'; setTimeout(()=>caret.style.animation='',120);
          }
          if (i >= text.length){ resolve(); return; }
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }
    async function erase(toLen, cps){
      const start = performance.now(); const fromLen = suffix.textContent.length;
      return new Promise(resolve=>{
        function tick(){
          const elapsed = (performance.now()-start)/1000;
          const target = Math.floor(elapsed*cps);
          const next = Math.max(fromLen - target, toLen);
          if (suffix.textContent.length !== next){
            suffix.textContent = suffix.textContent.slice(0, next);
            positionCaret();
            caret.style.animation='jiggle 120ms ease-out'; setTimeout(()=>caret.style.animation='',120);
          }
          if (next <= toLen){ resolve(); return; }
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    let firstCycleDone = false;
    async function loop(){
      while(true){
        suffix.textContent = '';
        positionCaret();
        await type('cheat.cc', 7);
        await sleep(900);
        await erase(0, 7);
        if (!prefersReduced){ caret.style.opacity='0'; await sleep(240); caret.style.opacity=''; }
        await type('ify', 4);
        await sleep(1800);
        await erase(0, 9);
        await sleep(500);
        if (!firstCycleDone){
          firstCycleDone = true;
          if (titleEl && titleEl.getAttribute('aria-live')){
            titleEl.removeAttribute('aria-live');
          }
        }
      }
    }
    loop();
  })();

  /* ================= OAuth (unchanged) ================= */
  const CLIENT_ID = "ec6dea15d2df46efbb5cc43de67768b3";
  const REDIRECT_URI = "https://quaii.github.io/Plagueify/";
  const SCOPES = "";

  const $ = id => document.getElementById(id);
  const screenA = $('screenA'), screenB = $('screenB');
  const statusA = $('statusA'), statusB = $('statusB');
  const btnLogin = $('btn-login'), btnCopy = $('btn-copy'), tokenBox = $('tokenBox');

  function randomId(){
    return Array(32).fill(0).map(()=>Math.random().toString(36)[2]||0).join('');
  }

  async function oauth(){
    const state = randomId();
    localStorage.setItem('oauth_state', state);
    const params = new URLSearchParams({
      response_type: 'token',
      client_id: CLIENT_ID,
      scope: SCOPES,
      redirect_uri: REDIRECT_URI,
      state,
      show_dialog: 'true'
    });
    window.location.href = `https://accounts.spotify.com/authorize?${params}`;
  }

  function parseUrl(){
    const frag = window.location.hash.substring(1);
    if (!frag) return {};
    const obj = {};
    for (const kv of frag.split('&')){
      const [k, v] = kv.split('=');
      if (k && v) obj[k] = decodeURIComponent(v);
    }
    return obj;
  }

  async function handleToken(){
    const { access_token, state, error } = parseUrl();
    if (error) {
      statusA.textContent = '🚫 Authorization failed.';
      statusA.className = 'muted err';
      return;
    }
    if (!access_token) return;

    const saved = localStorage.getItem('oauth_state');
    if (state !== saved) {
      statusA.textContent = '🚫 State mismatch.';
      statusA.className = 'muted err';
      return;
    }

    localStorage.removeItem('oauth_state');
    window.history.replaceState({}, document.title, window.location.pathname);

    // display token
    screenA.classList.add('hide');
    screenB.classList.remove('hide');
    tokenBox.value = access_token;

    statusB.textContent = '✅ Success! This token expires in 1 hour.';
    statusB.className = 'muted ok';
  }

  btnLogin.addEventListener('click', oauth);
  btnCopy.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(tokenBox.value);
      statusB.textContent = '📋 Copied to clipboard!';
      statusB.className = 'muted ok';
    } catch {
      tokenBox.select();
      statusB.textContent = '📋 Selected — press Ctrl+C to copy.';
      statusB.className = 'muted';
    }
  });

  handleToken();
});
</script>
</body>
</html>
