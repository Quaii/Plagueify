<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Plagueify — Refresh Token</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="color-scheme" content="dark" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root{
    color-scheme:dark;
    --bg:#0b0b0c; --ink:#e8e8ea; --line:#2b2f36;
    --blue1:#6da5ff; --blue2:#3a6df5; --blue3:#4a82ff;
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    background:var(--bg); color:var(--ink);
    font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overflow:hidden; cursor:none; /* we draw our own */
  }

  /* Frosted-glass + raindrops canvas (never intercepts clicks) */
  #bg{position:fixed; inset:0; width:100%; height:100%; display:block; z-index:0; pointer-events:none;}

  /* Fixed decorative overlays stacked above canvas, below stage */
  .fxLayer{position:fixed; inset:0; z-index:0; pointer-events:none}
  /* Layer 1 — whisper tech grid */
  .gridLayer{
    opacity:.16; /* ≤ 0.25 overall */
    mix-blend-mode:overlay;
    background-image:
      repeating-linear-gradient(0deg, rgba(100,150,255,.12), rgba(100,150,255,.12) 1px, transparent 1px, transparent 24px),
      repeating-linear-gradient(90deg, rgba(100,150,255,.12), rgba(100,150,255,.12) 1px, transparent 1px, transparent 24px);
    /* Avoid moiré by letting the blend mask most of the grid on brights */
  }
  /* Layer 2 — soft blue bloom "nebula" */
  .bloomLayer{
    opacity:.6; /* combined under ~0.9 with blends */
    mix-blend-mode:screen;
    filter:blur(44px);
    background:
      radial-gradient(40% 40% at 28% 32%, rgba(109,165,255,.45), rgba(109,165,255,0) 60%),
      radial-gradient(46% 46% at 72% 68%, rgba(58,109,245,.38), rgba(58,109,245,0) 62%),
      radial-gradient(30% 30% at 50% 50%, rgba(74,130,255,.28), rgba(74,130,255,0) 65%);
  }
  /* Layer 3 — micro-grain for glass tooth */
  .grainLayer{
    opacity:.1; /* ≤ 0.12 */
    mix-blend-mode:soft-light;
    background-image: radial-gradient(rgba(255,255,255,.12) 0.5px, transparent 0.6px);
    background-size: 3px 3px;
    background-position: 0 0;
  }

  .stage{position:relative; z-index:1; height:100%; display:grid; place-items:center; padding:24px; overflow:visible;}
  .container{width:min(820px,92vw); opacity:0; transform:translateY(8px) scale(.985)}
  .in{animation:fadeIn .7s cubic-bezier(.2,.75,.2,1) .05s forwards}
  @keyframes fadeIn{to{opacity:1; transform:translateY(0) scale(1)}}

  /* Title */
  .title{
    font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    font-weight:800; letter-spacing:.2px;
    font-size:clamp(48px,10vw,98px);
    line-height:1; user-select:none; text-align:center;
    margin:0 0 36px 0; white-space:nowrap; overflow:visible;
    text-shadow:0 0 10px rgba(90,140,255,.18); /* glow, not bloom */
  }
  .titleRow{display:inline-flex; align-items:baseline; gap:0; overflow:visible;}
  .titleRow{white-space:nowrap; transform:translateX(var(--titleBias, 0px));}
  .blueGrad{
    background:linear-gradient(180deg,var(--blue1) 0%,var(--blue3) 50%,var(--blue2) 100%);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    filter:drop-shadow(0 0 8px rgba(90,140,255,.18));
  }

  /* Suffix lane: fixed width = width of longest word so centering doesn't shift */
  .suffixLane{
    position:relative; display:inline-flex; align-items:baseline; vertical-align:baseline;
    min-width:10px; /* measured & set at runtime */
    height:1em; line-height:1; /* ensure stable line-box */
  }
  .suffixText{ color:#fff; letter-spacing:0; display:inline-block; white-space:nowrap; line-height:1; vertical-align:baseline; }
  .caret{
    position:absolute; left:0; top:0.032em; display:block; width:0.055em; height:0.95em; background:#fff;
    /* margin handled via JS positioning to hug text */
    will-change:transform, opacity;
  }
  @keyframes blink{0%,45%{opacity:1}55%,100%{opacity:.18}}
  .blink{animation:blink 950ms step-end infinite}
  /* Softer caret blink for idle state */
  @keyframes caretBlink{0%,100%{opacity:1}50%{opacity:0}}
  .caret.blink{animation:caretBlink 1s step-end infinite; transition:opacity .15s ease}
  @keyframes jiggle{0%{transform:translateY(0)}50%{transform:translateY(-1px)}100%{transform:translateY(0)}}

  /* Token UI */
  .block{width:min(700px,86vw); margin:0 auto}
  .label{font-weight:700; margin:0 0 8px 6px;}
  .token{
    width:100%; padding:12px 14px; background:#121317cc; color:var(--ink);
    border:1px solid var(--line); border-radius:0;
    font-family:ui-monospace,Menlo,Consolas,monospace; font-size:.95rem;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    outline:none; backdrop-filter:blur(2px);
    transition:border-color .18s ease, transform .18s ease;
  }
  .token:focus{border-color:#3c68ff; transform:translateY(-1px)}

  .controls{text-align:center; margin-top:16px}
  .btn{
    appearance:none; border:1px solid var(--line); background:#1a1c21; color:var(--ink);
    padding:12px 18px; border-radius:0; font-weight:700; letter-spacing:.2px;
    transition:transform .12s, border-color .2s, box-shadow .2s, background .2s;
    box-shadow:0 12px 28px rgba(0,0,0,.28);
  }
  .btn:hover{ transform:translateY(-1px); border-color:#3a4050; background:#1f2228; box-shadow:0 16px 34px rgba(0,0,0,.36) }
  .hero{display:flex; flex-direction:column; align-items:center; gap:28px}
  .btn-cta{ padding:14px 22px }

  /* Focus visibility for keyboard users */
  .btn:focus-visible{
    outline:2px solid #4a82ff; outline-offset:2px; border-color:#4a82ff;
    box-shadow:0 0 0 4px rgba(74,130,255,.22), 0 12px 28px rgba(0,0,0,.28);
  }
  .token:focus-visible{
    outline:2px solid #4a82ff; outline-offset:2px; border-color:#3c68ff;
  }
  /* Ensure OS cursor never shows on interactives */
  a, button, [role="button"], input, textarea, select, .btn, .token { cursor:none; }

  .hide{display:none !important}
  .muted{opacity:.72; font-size:.95rem; text-align:center; margin-top:10px}
  .ok{color:#9ae6a0} .err{color:#ff8c8c}

  /* Custom cursor — pure glow */
  .cursorRing{
    position:fixed; left:50%; top:50%;
    width:1px; height:1px; border-radius:50%; pointer-events:none;
    z-index:9999; /* always above */
    background:transparent; border:none; mix-blend-mode:screen;
    box-shadow:
      0 0 24px  rgba(90,140,255,0.18),
      0 0 48px  rgba(90,140,255,0.12),
      0 0 80px  rgba(90,140,255,0.10),
      0 0 160px rgba(90,140,255,0.08),
      0 0 240px rgba(90,140,255,0.06),
      0 0 320px rgba(90,140,255,0.04),
      0 0 480px rgba(90,140,255,0.025);
    transform:translate(-50%,-50%);
  }

  /* Respect reduced motion: hide overlays, stop caret blink */
  @media (prefers-reduced-motion: reduce){
    .gridLayer, .bloomLayer, .grainLayer{display:none !important}
    .blink{animation:none}
    .cursorRing{display:none !important}
  }

  /* Hide ring on coarse pointers (touch devices) */
  @media (pointer: coarse){ .cursorRing{ display:none !important } }
</style>
</head>
<body>
  <!-- Frosted glass + raindrops -->
  <canvas id="bg" aria-hidden="true"></canvas>

  <!-- Decorative layers -->
  <div class="fxLayer gridLayer" aria-hidden="true"></div>
  <div class="fxLayer bloomLayer" aria-hidden="true"></div>
  <div class="fxLayer grainLayer" aria-hidden="true"></div>

  <!-- Custom glow cursor -->
  <div class="cursorRing" id="ring"></div>

  <div class="stage">
    <div class="container" id="container">
      <!-- Screen A -->
      <section id="screenA" class="hero">
        <h1 class="title" aria-live="polite">
          <span class="titleRow">
            <span class="blueGrad">Plague</span>
            <span class="suffixLane"><span id="suffix" class="suffixText"></span><span id="caret" class="caret"></span></span>
          </span>
        </h1>
        <button class="btn btn-cta" id="btn-login">Sign in to Spotify</button>
        <div id="statusA" class="muted"></div>
      </section>

      <!-- Screen B -->
      <section id="screenB" class="hide">
        <h1 class="title">
          <span class="titleRow"><span class="blueGrad">Plague</span><span class="suffixText">ify</span></span>
        </h1>
        <div class="block">
          <p class="label">Your Token</p>
          <input id="tokenBox" class="token" type="text" readonly />
          <div class="controls"><button class="btn" id="btn-copy">Manual Copy</button></div>
          <div id="statusB" class="muted"></div>
        </div>
      </section>
    </div>
  </div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('container').classList.add('in');

  /* ================= Frosted glass + glowing raindrops ================= */
  (function frosted(){
    const c = document.getElementById('bg');
    const ctx = c.getContext('2d');
    const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
    let w,h,dpr;
    let dropsBack=[], dropsMid=[], dropsFront=[], heroOrbs=[];
    // Rare streaks and shooting stars
    let blueStreaks=[]; // 2–3 max
    let shootingStars=[]; // ≤ 2 active
    let lastStarSpawn=0;
    let lastT = performance.now();
    // Parallax tracking
    let tpx = 0, tpy = 0, ppx = 0, ppy = 0;
    function onPointer(e){
      const p = e.touches? e.touches[0]: e;
      const nx = (p.clientX / w) - 0.5;
      const ny = (p.clientY / h) - 0.5;
      tpx = nx; tpy = ny;
    }
    if (!prefersReduced){
      addEventListener('pointermove', onPointer, {passive:true});
      addEventListener('touchmove', onPointer, {passive:true});
    }

    function resize(){
      w = innerWidth; h = innerHeight; dpr = Math.min(2, devicePixelRatio||1);
      c.style.width = w+'px'; c.style.height = h+'px';
      c.width = (w*dpr)|0; c.height = (h*dpr)|0;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // rebuild drops by strata (density +25%)
      const baseCount = Math.floor((w*h)/30000);
      const MAX_TOTAL = 900; // safety cap for ultra-wide
      const backCount = Math.max(0, Math.floor(baseCount*0.5));
      const midCount  = Math.max(0, Math.floor(baseCount*0.35));
      const frontCount= Math.max(0, Math.floor(baseCount*0.15));
      const heroCount = Math.max(5, Math.min(8, Math.floor((w+h)/1200)));
      const total = backCount+midCount+frontCount+heroCount;
      const scale = total>MAX_TOTAL ? MAX_TOTAL/total : 1;

      function fill(count, kind){
        return new Array(Math.floor(count*scale)).fill(0).map(()=>spawn(kind));
      }
      dropsBack = fill(backCount, 'back');
      dropsMid  = fill(midCount,  'mid');
      dropsFront= fill(frontCount,'front');
      heroOrbs  = fill(heroCount, 'hero');
      // initialize streak pools
      blueStreaks = new Array(3).fill(0).map(()=>spawnStreak());
      shootingStars = [];
    }
    function spawn(kind){
      const layer = kind;
      let r, vy, sway, alpha;
      if (layer==='back'){
        r = 0.8 + Math.random()*1.2;
        vy = 0.6 + Math.random()*1.1; // faster
        sway = (Math.random()-.5)*0.28;
        alpha = 0.14 + Math.random()*0.22;
      } else if (layer==='mid'){
        r = 1 + Math.random()*2.2;
        vy = 0.3 + Math.random()*0.8; // original feel
        sway = (Math.random()-.5)*0.25;
        alpha = 0.18 + Math.random()*0.26;
      } else if (layer==='front'){
        r = 2.2 + Math.random()*3.2;
        vy = 0.18 + Math.random()*0.45; // slower
        sway = (Math.random()-.5)*0.22;
        alpha = 0.16 + Math.random()*0.22;
      } else { // hero
        r = 6 + Math.random()*10;
        vy = 0.05 + Math.random()*0.12; // very slow
        sway = (Math.random()-.5)*0.18;
        alpha = 0.10 + Math.random()*0.14;
      }
      const twinkle = Math.random() < 0.19 && layer!=='hero';
      return {
        x: Math.random()*w, y: Math.random()*h,
        r, vy, sway,
        hue: 215 + Math.random()*18,
        alpha,
        twinkle,
        twFreq: 0.6 + Math.random()*0.8,
        twPhase: Math.random()*Math.PI*2,
        layer
      };
    }
    function spawnStreak(){
      // inactive until scheduled
      return { active:false, x:0, y:0, vx:0, vy:0, life:0, ttl:0, hue:215+Math.random()*18, cooldown: 2000 + Math.random()*6000 };
    }
    function maybeActivateStreak(s){
      if (s.active) return;
      if (s.cooldown>0){ s.cooldown -= 16; return; }
      // launch with shallow diagonal
      const startSide = Math.random()<0.5? 'top':'left';
      if (startSide==='top'){ s.x = Math.random()*w*0.6; s.y = -20; } else { s.x = -20; s.y = Math.random()*h*0.6; }
      const speed = 0.8 + Math.random()*1.4; // px per frame @ ~60 fps
      const angle = (Math.PI/4) * (0.75 + Math.random()*0.5); // around 45°
      s.vx = Math.cos(angle)*speed; s.vy = Math.sin(angle)*speed;
      s.ttl = 1200 + Math.random()*400; s.life = 0; s.active = true; s.cooldown = 6000 + Math.random()*4000;
    }
    function stepDrawStreaks(t){
      ctx.lineCap = 'round';
      for (const s of blueStreaks){
        maybeActivateStreak(s);
        if (!s.active) continue;
        s.life += 16;
        s.x += s.vx; s.y += s.vy;
        // draw short trail segment
        const trail = 24;
        const x2 = s.x - s.vx*trail; const y2 = s.y - s.vy*trail;
        const alpha = 0.25 * (1 - s.life/s.ttl);
        ctx.strokeStyle = `hsla(${s.hue}, 80%, 60%, ${Math.max(0,alpha)})`;
        ctx.shadowColor = `hsla(${s.hue}, 80%, 60%, ${Math.max(0,alpha)})`;
        ctx.shadowBlur = 12;
        ctx.lineWidth = 1.25;
        ctx.beginPath(); ctx.moveTo(x2,y2); ctx.lineTo(s.x,s.y); ctx.stroke();
        ctx.shadowBlur = 0;
        if (s.life >= s.ttl || s.x> w+40 || s.y> h+40) { s.active=false; }
      }
    }
    function maybeSpawnStar(now){
      if (shootingStars.length >= 2) return;
      if (now - lastStarSpawn < 1000) return; // ≤ 1/s
      lastStarSpawn = now;
      const startX = w*0.12 + (Math.random()*0.06-0.03)*w;
      const startY = h*0.50 + (Math.random()*0.06-0.03)*h;
      const ctrlX  = w*0.50;
      const ctrlY  = h*0.24;
      const endX   = w*0.88 + (Math.random()*0.06-0.03)*w;
      const endY   = h*0.50 + (Math.random()*0.06-0.03)*h;
      const ttl    = 1900 + Math.random()*600;
      const r      = 9 + Math.random()*3;
      shootingStars.push({ t:0, ttl, r, startX, startY, ctrlX, ctrlY, endX, endY, sparkles:[] });
    }
    function quadAt(p0, p1, p2, t){ const u=1-t; return u*u*p0 + 2*u*t*p1 + t*t*p2; }
    function stepDrawStars(dt){
      for (let i=shootingStars.length-1;i>=0;i--){
        const s = shootingStars[i];
        s.t += dt/ s.ttl; if (s.t>1) s.t=1;
        const x = quadAt(s.startX, s.ctrlX, s.endX, s.t);
        const y = quadAt(s.startY, s.ctrlY, s.endY, s.t);
        // Head glow (warm)
        const headA = 0.9 * (1 - s.t*0.2);
        ctx.save(); ctx.globalCompositeOperation='screen';
        ctx.shadowBlur = 110; ctx.shadowColor = `rgba(255,245,200,${headA})`;
        ctx.fillStyle = `rgba(255,252,235,${headA})`;
        ctx.beginPath(); ctx.arc(x,y,s.r,0,Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        // Long tapered trail along the curve using segments
        const segments = 48; const tailLen = Math.max(w,h)*0.34; // ~34% viewport
        for (let k=0;k<segments;k++){
          const f = k/segments;
          const tseg = Math.max(0, s.t - (1-f)*(tailLen/(s.ttl*0.18))); // spread along path
          const tx = quadAt(s.startX, s.ctrlX, s.endX, tseg);
          const ty = quadAt(s.startY, s.ctrlY, s.endY, tseg);
          const fall = Math.pow(1 - f, 2.2);
          // warm to cool gradient along tail
          let col;
          if (f < 0.35){ col = `rgba(255,220,120,${0.42*fall})`; }
          else if (f < 0.7){ col = `rgba(255,120,90,${0.30*fall})`; }
          else { col = `rgba(120,170,255,${0.22*fall})`; }
          ctx.fillStyle = col;
          const rr = s.r * (1 - f*0.85);
          ctx.beginPath(); ctx.arc(tx, ty, rr, 0, Math.PI*2); ctx.fill();
        }
        // Sparkles near end of path
        if (Math.random()<0.25 && s.t>0.7 && s.sparkles.length<5){
          s.sparkles.push({ x:x + (Math.random()*12-6), y:y+(Math.random()*12-6), life:0, ttl:150+Math.random()*100 });
        }
        for (let j=s.sparkles.length-1;j>=0;j--){
          const sp = s.sparkles[j]; sp.life += dt; const aa = Math.max(0, 0.6*(1 - sp.life/sp.ttl));
          ctx.fillStyle = `rgba(220,240,255,${aa})`; ctx.beginPath(); ctx.arc(sp.x, sp.y, 1 + Math.random()*0.6, 0, Math.PI*2); ctx.fill();
          if (sp.life>=sp.ttl) s.sparkles.splice(j,1);
        }
        ctx.restore();
        if (s.t>=1) { shootingStars.splice(i,1); }
      }
    }
    function drawGlass(){
      // soft frosted plate in center
      const g = ctx.createRadialGradient(w*0.5, h*0.45, Math.min(w,h)*0.1, w*0.5, h*0.45, Math.min(w,h)*0.6);
      g.addColorStop(0, '#0f141f');
      g.addColorStop(1, '#0b0b0c');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }
    function stepAndDrawSet(set, t){
      for (const d of set){
        d.y += d.vy; d.x += d.sway;
        if (d.y - d.r > h+10) { d.y = -10; d.x = Math.random()*w; }
        const tw = d.twinkle ? (0.88 + 0.12*Math.sin(t*d.twFreq + d.twPhase)) : 1;
        const a = d.alpha * tw;
        ctx.shadowColor = `hsla(${d.hue}, 80%, 60%, ${a})`;
        ctx.fillStyle   = `hsla(${d.hue}, 80%, 60%, ${a*0.65})`;
        ctx.shadowBlur  = d.layer==='hero' ? 24 : (d.layer==='front' ? 18 : (d.layer==='mid' ? 14 : 10));
        ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, Math.PI*2); ctx.fill();
      }
    }
    function draw(now){
      const dt = Math.min(100, now - lastT); // clamp
      lastT = now;
      const t = now/1000;
      // Ease parallax (snappier)
      ppx += (tpx - ppx) * 0.08;
      ppy += (tpy - ppy) * 0.08;
      drawGlass();
      ctx.globalCompositeOperation = 'screen';
      // Back layer parallax (largest shift)
      ctx.save(); ctx.translate(ppx*12, ppy*12); stepAndDrawSet(dropsBack, t); ctx.restore();
      // Mid layer parallax
      ctx.save(); ctx.translate(ppx*8, ppy*8); stepAndDrawSet(dropsMid, t); ctx.restore();
      // Front layer parallax
      ctx.save(); ctx.translate(ppx*5, ppy*5); stepAndDrawSet(dropsFront, t); ctx.restore();
      // Hero orbs minimal shift to keep legible
      ctx.save(); ctx.translate(ppx*3, ppy*3); stepAndDrawSet(heroOrbs, t); ctx.restore();
      // Blue streaks
      stepDrawStreaks(t);
      // Shooting stars
      maybeSpawnStar(now, w, h);
      stepDrawStars(ctx, w, h, dt);
      ctx.shadowBlur = 0;
      ctx.globalCompositeOperation = 'source-over';
      if (!prefersReduced) requestAnimationFrame(draw);
    }
    resize(); addEventListener('resize', resize);
    if (prefersReduced){
      drawGlass();
    } else {
      requestAnimationFrame(draw);
    }
  })();

  /* ================= Precise glow cursor (ring only) ================= */
  (function cursorRing(){
    const ring = document.getElementById('ring');
    const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
    const isCoarse = matchMedia('(pointer: coarse)').matches;
    if (prefersReduced || isCoarse){ ring.style.display='none'; return; }
    let rx = innerWidth/2, ry = innerHeight/2, tx = rx, ty = ry;
    let throttleFlip = false;
    const heavy = (innerWidth*innerHeight*(window.devicePixelRatio||1)) > 5_000_000;
    function move(e){ const t = e.touches?e.touches[0]:e; tx=t.clientX; ty=t.clientY; }
    addEventListener('pointermove', move, {passive:true});
    function isInteractiveAt(x,y){
      const el = document.elementFromPoint(x,y);
      if (!el) return false;
      const sel = 'button, a, [role="button"], input, textarea, select, .btn';
      return el.closest(sel) != null;
    }
    (function tick(){
      if (heavy){ throttleFlip = !throttleFlip; if (throttleFlip){ requestAnimationFrame(tick); return; } }
      rx += (tx - rx) * 0.18; ry += (ty - ry) * 0.18;
      const overInteractive = isInteractiveAt(tx,ty);
      ring.style.left = rx+'px'; ring.style.top = ry+'px';
      ring.style.transform = 'translate(-50%,-50%)';
      ring.style.boxShadow = overInteractive
        ? '0 0 24px rgba(90,140,255,.26), 0 0 48px rgba(90,140,255,.20), 0 0 96px rgba(90,140,255,.16), 0 0 160px rgba(90,140,255,.12), 0 0 240px rgba(90,140,255,.10), 0 0 320px rgba(90,140,255,.07), 0 0 480px rgba(90,140,255,.04)'
        : '0 0 24px rgba(90,140,255,.18), 0 0 48px rgba(90,140,255,.12), 0 0 80px rgba(90,140,255,.085), 0 0 160px rgba(90,140,255,.07), 0 0 240px rgba(90,140,255,.045), 0 0 320px rgba(90,140,255,.032), 0 0 480px rgba(90,140,255,.025)';
      requestAnimationFrame(tick);
    })();
  })();

  /* ================= Typing (suffix only, anchored, smooth, loop) ================= */
  (function typing(){
    const suffixLane = document.querySelector('.suffixLane');
    const suffix = document.getElementById('suffix');
    const caret = document.getElementById('caret');
    const titleEl = document.querySelector('h1.title');
    const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;
    const titleRow = document.querySelector('.titleRow');

    // Measure max width using an offscreen span so center stays steady
    const measure = (text)=>{
      const s = document.createElement('span');
      s.style.visibility='hidden'; s.style.position='absolute'; s.style.whiteSpace='nowrap';
      s.className = 'suffixText';
      s.textContent = text;
      document.body.appendChild(s);
      const w = s.getBoundingClientRect().width;
      document.body.removeChild(s);
      return w;
    };
    const MAX_SUFFIX = 'cheat.cc'; // lowercase 'c' per spec
    suffixLane.style.minWidth = Math.ceil(measure(MAX_SUFFIX)) + 'px';
    // Precision bias calculation with anti-clip clamp
    function recalcBias(){
      const S_short = measure('ify');
      const S_long = measure('cheat.cc');
      const titleElForSize = document.querySelector('.title');
      const titleFontSize = parseFloat(getComputedStyle(titleElForSize).fontSize)||98;
      const k = Math.max(3, Math.min(8, Math.floor(0.03 * titleFontSize)));
      let biasX = (S_short - S_long)/4 + k;
      const container = document.getElementById('container');
      if (container && titleRow){
        const contRect = container.getBoundingClientRect();
        const rowRect = titleRow.getBoundingClientRect();
        const minLeft = contRect.left + 24;
        const newLeft = rowRect.left + biasX;
        if (newLeft < minLeft){ biasX += (minLeft - newLeft); }
      }
      if (titleRow){ titleRow.style.setProperty('--titleBias', biasX.toFixed(2)+'px'); }
    }
    recalcBias();
    addEventListener('resize', recalcBias);
    // tweak after fonts/animation settle
    setTimeout(recalcBias, 700);
    document.addEventListener('visibilitychange', ()=>{ if (!document.hidden) recalcBias(); });

    const sleep = ms => new Promise(r=>setTimeout(r, ms));

    // Hidden measurer for per-prefix width without reflowing main layout
    const measurer = document.createElement('span');
    measurer.style.cssText = 'position:absolute;visibility:hidden;white-space:nowrap;left:-9999px;top:-9999px;';
    measurer.className = 'suffixText';
    document.body.appendChild(measurer);
    function measurePrefixWidth(text){ measurer.textContent = text; return measurer.getBoundingClientRect().width; }
    function positionCaret(){ const w = measurePrefixWidth(suffix.textContent); const px = (window.devicePixelRatio? Math.round((w+6)*window.devicePixelRatio)/window.devicePixelRatio : (w+6)); caret.style.transform = 'translateX(' + px + 'px)'; }

    // Precompute advance arrays for cached caret positions
    function measureWidth(text){ measurer.textContent = text; return measurer.getBoundingClientRect().width; }
    function computeAdvances(text){
      const advances = [0];
      for (let i=1;i<=text.length;i++) advances[i] = measureWidth(text.slice(0,i));
      return advances;
    }
    const advancesCheat = computeAdvances('cheat.cc');
    const advancesIfy = computeAdvances('ify');
    function toDevicePx(x){ const dpr = window.devicePixelRatio||1; return Math.round(x*dpr)/dpr; }
    function setCaretFor(text, i){
      const adv = text==='cheat.cc'? advancesCheat[i] : text==='ify'? advancesIfy[i] : measureWidth(text.slice(0,i));
      const px = toDevicePx(adv + 6);
      caret.style.transform = 'translateX(' + px + 'px)';
    }
    function makeStepperWithCache(forward){
      return (text, cps)=> new Promise(resolve=>{
        let acc = 0; let i = forward ? 0 : suffix.textContent.length;
        function tick(now){
          const prev = tick.prev || now; const dt = Math.min(0.05, (now - prev)/1000); tick.prev = now;
          acc += cps * dt;
          if (acc >= 1){
            acc -= 1;
            if (forward){ if (i < text.length){ i++; suffix.textContent = text.slice(0, i); } }
            else { if (i > 0){ i--; suffix.textContent = suffix.textContent.slice(0, i); } }
            setCaretFor(text, i);
            // disable blink during motion
            caret.classList.remove('blink');
          }
          const done = forward ? (i>=text.length) : (i<=0);
          if (done){ resolve(); return; }
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }
    const type = makeStepperWithCache(true);
    const eraseToZero = (cps)=> makeStepperWithCache(false)('', cps);

    let firstCycleDone = false;
    async function loop(){
      while(true){
        caret.classList.remove('blink');
        suffix.textContent = '';
        positionCaret();
        await type('cheat.cc', 4);
        caret.classList.add('blink');
        await sleep(1400 + Math.random()*200);
        await eraseToZero(4);
        if (!prefersReduced){ caret.style.opacity='0'; await sleep(220 + Math.random()*80); caret.style.opacity=''; }
        await type('ify', 3);
        caret.classList.add('blink');
        await sleep(2600 + Math.random()*400);
        await eraseToZero(3);
        caret.classList.add('blink');
        await sleep(500);
        if (!firstCycleDone){
          firstCycleDone = true;
          if (titleEl && titleEl.getAttribute('aria-live')){
            titleEl.removeAttribute('aria-live');
          }
          // re-evaluate bias after first cycle fully completes
          try { recalcBias(); } catch {}
        }
      }
    }
    loop();
  })();

  /* ================= OAuth (unchanged) ================= */
  const CLIENT_ID = "ec6dea15d2df46efbb5cc43de67768b3";
  const REDIRECT_URI = "https://quaii.github.io/Plagueify/";
  const SCOPES = "";

  const $ = id => document.getElementById(id);
  const screenA = $('screenA'), screenB = $('screenB');
  const statusA = $('statusA'), statusB = $('statusB');
  const btnLogin = $('btn-login'), btnCopy = $('btn-copy'), tokenBox = $('tokenBox');

  function randomId(){
    return Array(32).fill(0).map(()=>Math.random().toString(36)[2]||0).join('');
  }

  async function oauth(){
    const state = randomId();
    localStorage.setItem('oauth_state', state);
    const params = new URLSearchParams({
      response_type: 'token',
      client_id: CLIENT_ID,
      scope: SCOPES,
      redirect_uri: REDIRECT_URI,
      state,
      show_dialog: 'true'
    });
    window.location.href = `https://accounts.spotify.com/authorize?${params}`;
  }

  function parseUrl(){
    const frag = window.location.hash.substring(1);
    if (!frag) return {};
    const obj = {};
    for (const kv of frag.split('&')){
      const [k, v] = kv.split('=');
      if (k && v) obj[k] = decodeURIComponent(v);
    }
    return obj;
  }

  async function handleToken(){
    const { access_token, state, error } = parseUrl();
    if (error) {
      statusA.textContent = '🚫 Authorization failed.';
      statusA.className = 'muted err';
      return;
    }
    if (!access_token) return;

    const saved = localStorage.getItem('oauth_state');
    if (state !== saved) {
      statusA.textContent = '🚫 State mismatch.';
      statusA.className = 'muted err';
      return;
    }

    localStorage.removeItem('oauth_state');
    window.history.replaceState({}, document.title, window.location.pathname);

    // display token
    screenA.classList.add('hide');
    screenB.classList.remove('hide');
    tokenBox.value = access_token;

    statusB.textContent = '✅ Success! This token expires in 1 hour.';
    statusB.className = 'muted ok';
  }

  btnLogin.addEventListener('click', oauth);
  btnCopy.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(tokenBox.value);
      statusB.textContent = '📋 Copied to clipboard!';
      statusB.className = 'muted ok';
    } catch {
      tokenBox.select();
      statusB.textContent = '📋 Selected — press Ctrl+C to copy.';
      statusB.className = 'muted';
    }
  });

  handleToken();
});
</script>
</body>
</html>
