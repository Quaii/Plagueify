<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Plagueify — Refresh Token</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="color-scheme" content="dark" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@700;800&display=swap" rel="stylesheet">
<style>
  :root{
    color-scheme:dark;
    --bg:#0b0b0c; --ink:#e8e8ea; --line:#2b2f36;
    --blue1:#6da5ff; --blue2:#3a6df5; --blue3:#4a82ff;
  }
  *,*::before,*::after{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    background:var(--bg); color:var(--ink);
    font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overflow:hidden; cursor:none; /* we draw our own */
  }

  /* Frosted-glass + raindrops canvas (never intercepts clicks) */
  #bg{position:fixed; inset:0; width:100%; height:100%; display:block; z-index:0; pointer-events:none;}

  .stage{position:relative; z-index:1; height:100%; display:grid; place-items:center; padding:24px; overflow:visible;}
  .container{width:min(820px,92vw); opacity:0; transform:translateY(8px) scale(.985)}
  .in{animation:fadeIn .7s cubic-bezier(.2,.75,.2,1) .05s forwards}
  @keyframes fadeIn{to{opacity:1; transform:translateY(0) scale(1)}}

  /* Title */
  .title{
    font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    font-weight:800; letter-spacing:.2px;
    font-size:clamp(48px,10vw,98px);
    line-height:.95; user-select:none; text-align:center;
    margin:0 0 36px 0; white-space:nowrap; overflow:visible;
    text-shadow:0 0 10px rgba(90,140,255,.18); /* glow, not bloom */
  }
  .titleRow{display:inline-flex; align-items:baseline; gap:0; overflow:visible;}
  .blueGrad{
    background:linear-gradient(180deg,var(--blue1) 0%,var(--blue3) 50%,var(--blue2) 100%);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    filter:drop-shadow(0 0 8px rgba(90,140,255,.18));
  }

  /* Suffix lane: fixed width = width of longest word so centering doesn't shift */
  .suffixLane{
    position:relative; display:inline-block; vertical-align:baseline;
    min-width:10px; /* measured & set at runtime */
  }
  .suffixText{ color:#fff; letter-spacing:0; display:inline; }
  .caret{
    display:inline-block; width:0.055em; height:0.95em; background:#fff;
    margin-left:6px; vertical-align:-0.05em;
  }
  @keyframes blink{0%,45%{opacity:1}55%,100%{opacity:.18}}
  .blink{animation:blink 950ms step-end infinite}
  @keyframes jiggle{0%{transform:translateY(0)}50%{transform:translateY(-1px)}100%{transform:translateY(0)}}

  /* Token UI */
  .block{width:min(700px,86vw); margin:0 auto}
  .label{font-weight:700; margin:0 0 8px 6px;}
  .token{
    width:100%; padding:12px 14px; background:#121317cc; color:var(--ink);
    border:1px solid var(--line); border-radius:0;
    font-family:ui-monospace,Menlo,Consolas,monospace; font-size:.95rem;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    outline:none; backdrop-filter:blur(2px);
    transition:border-color .18s ease, transform .18s ease;
  }
  .token:focus{border-color:#3c68ff; transform:translateY(-1px)}

  .controls{text-align:center; margin-top:16px}
  .btn{
    appearance:none; border:1px solid var(--line); background:#1a1c21; color:var(--ink);
    padding:12px 18px; border-radius:0; font-weight:700; letter-spacing:.2px; cursor:pointer;
    transition:transform .12s, border-color .2s, box-shadow .2s, background .2s;
    box-shadow:0 12px 28px rgba(0,0,0,.28);
  }
  .btn:hover{ transform:translateY(-1px); border-color:#3a4050; background:#1f2228; box-shadow:0 16px 34px rgba(0,0,0,.36) }
  .hero{display:flex; flex-direction:column; align-items:center; gap:28px}
  .btn-cta{ padding:14px 22px }

  .hide{display:none !important}
  .muted{opacity:.72; font-size:.95rem; text-align:center; margin-top:10px}
  .ok{color:#9ae6a0} .err{color:#ff8c8c}

  /* Custom cursor — glow ring only */
  .cursorRing{
    position:fixed; left:50%; top:50%;
    width:42px; height:42px; border-radius:50%; pointer-events:none;
    z-index:9999; /* always above */
    border:1px solid rgba(120,165,255,.55);
    box-shadow:
      0 0 20px rgba(90,140,255,.35),
      inset 0 0 22px rgba(90,140,255,.25);
    transform:translate(-50%,-50%);
  }

  /* Sound toggle (no icon, no native cursor) */
  .mute{
    position:fixed; right:14px; bottom:14px; z-index:100;
    background:#121317e6; color:#cfd7ff; border:1px solid #2b2f36;
    padding:8px 12px; font-size:.85rem; letter-spacing:.2px;
    box-shadow:0 8px 22px rgba(0,0,0,.35);
    cursor:none; /* keep native cursor hidden even over the button */
  }
  .mute:hover{ background:#161922 }
</style>
</head>
<body>
  <!-- Frosted glass + raindrops -->
  <canvas id="bg" aria-hidden="true"></canvas>

  <!-- Custom glow cursor -->
  <div class="cursorRing" id="ring"></div>

  <!-- Typing sound toggle -->
  <button id="mute" class="mute" aria-pressed="true" title="Toggle typing sound (default muted)">Typing sound: off</button>

  <div class="stage">
    <div class="container" id="container">
      <!-- Screen A -->
      <section id="screenA" class="hero">
        <h1 class="title" aria-live="polite">
          <span class="titleRow">
            <span class="blueGrad">Plague</span>
            <span class="suffixLane"><span id="suffix" class="suffixText"></span></span>
            <span id="caret" class="caret blink"></span>
          </span>
        </h1>
        <button class="btn btn-cta" id="btn-login">Sign in to Spotify</button>
        <div id="statusA" class="muted"></div>
      </section>

      <!-- Screen B -->
      <section id="screenB" class="hide">
        <h1 class="title">
          <span class="titleRow"><span class="blueGrad">Plague</span><span class="suffixText">ify</span></span>
        </h1>
        <div class="block">
          <p class="label">Your Token</p>
          <input id="tokenBox" class="token" type="text" readonly />
          <div class="controls"><button class="btn" id="btn-copy">Manual Copy</button></div>
          <div id="statusB" class="muted"></div>
        </div>
      </section>
    </div>
  </div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('container').classList.add('in');

  /* ================= Frosted glass + glowing raindrops ================= */
  (function frosted(){
    const c = document.getElementById('bg');
    const ctx = c.getContext('2d');
    let w,h,dpr, drops=[];

    function resize(){
      w = innerWidth; h = innerHeight; dpr = Math.min(2, devicePixelRatio||1);
      c.style.width = w+'px'; c.style.height = h+'px';
      c.width = (w*dpr)|0; c.height = (h*dpr)|0;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      // rebuild drops
      const count = Math.floor((w*h)/38000); // scale with screen
      drops = new Array(count).fill(0).map(()=>spawn());
    }
    function spawn(){
      const r = 1 + Math.random()*2.2;
      return {
        x: Math.random()*w, y: Math.random()*h,
        r, vy: 0.3 + Math.random()*0.8, sway: (Math.random()-.5)*0.25,
        hue: 215 + Math.random()*18, alpha: 0.18 + Math.random()*0.25
      };
    }
    function drawGlass(){
      // soft frosted plate in center
      const g = ctx.createRadialGradient(w*0.5, h*0.45, Math.min(w,h)*0.1, w*0.5, h*0.45, Math.min(w,h)*0.6);
      g.addColorStop(0, '#0f141f');
      g.addColorStop(1, '#0b0b0c');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }
    function draw(){
      drawGlass();
      ctx.globalCompositeOperation = 'lighter';
      for (const d of drops){
        d.y += d.vy; d.x += d.sway;
        if (d.y - d.r > h+10) { d.y = -10; d.x = Math.random()*w; }
        ctx.shadowColor = `hsla(${d.hue}, 80%, 60%, ${d.alpha})`;
        ctx.shadowBlur = 14;
        ctx.fillStyle = `hsla(${d.hue}, 80%, 60%, ${d.alpha*0.65})`;
        ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, Math.PI*2); ctx.fill();
      }
      ctx.shadowBlur = 0;
      ctx.globalCompositeOperation = 'source-over';
      requestAnimationFrame(draw);
    }
    resize(); addEventListener('resize', resize); draw();
  })();

  /* ================= Precise glow cursor (ring only) ================= */
  (function cursorRing(){
    const ring = document.getElementById('ring');
    let rx = innerWidth/2, ry = innerHeight/2, tx = rx, ty = ry;
    function move(e){ const t = e.touches?e.touches[0]:e; tx=t.clientX; ty=t.clientY; }
    addEventListener('pointermove', move, {passive:true});
    addEventListener('touchmove', move, {passive:true});
    (function tick(){
      rx += (tx - rx) * 0.18; ry += (ty - ry) * 0.18;
      ring.style.left = rx+'px'; ring.style.top = ry+'px';
      requestAnimationFrame(tick);
    })();
  })();

  /* ================= Typing (suffix only, anchored, smooth, loop) ================= */
  (function typing(){
    const suffixLane = document.querySelector('.suffixLane');
    const suffix = document.getElementById('suffix');
    const caret = document.getElementById('caret');
    const muteBtn = document.getElementById('mute');

    // Measure max width using an offscreen span so center stays steady
    const measure = (text)=>{
      const s = document.createElement('span');
      s.style.visibility='hidden'; s.style.position='absolute'; s.style.whiteSpace='nowrap';
      s.className = 'suffixText';
      s.textContent = text;
      document.body.appendChild(s);
      const w = s.getBoundingClientRect().width;
      document.body.removeChild(s);
      return w;
    };
    const MAX_SUFFIX = 'cheat.cc'; // lowercase 'c' per spec
    suffixLane.style.minWidth = Math.ceil(measure(MAX_SUFFIX)) + 'px';

    // sound (nicer tap)
    let audioCtx=null, muted=true;
    const setMuted = m => { muted=m; muteBtn.textContent = 'Typing sound: ' + (muted?'off':'on'); muteBtn.setAttribute('aria-pressed', String(!muted)); };
    setMuted(true);
    muteBtn.addEventListener('click',()=>{ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); setMuted(!muted); });

    function tap(){
      if (muted || !audioCtx) return;
      const ctx = audioCtx;
      // short filtered noise burst
      const noise = ctx.createBufferSource();
      const buffer = ctx.createBuffer(1, 4410, 44100); // 0.1s
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.pow(1 - i/data.length, 2); }
      noise.buffer = buffer;

      const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1600; bp.Q.value=5;
      const g = ctx.createGain(); g.gain.value = 0.08;

      noise.connect(bp).connect(g).connect(ctx.destination);
      const t = ctx.currentTime;
      noise.start(t); g.gain.exponentialRampToValueAtTime(0.0001, t+0.06); noise.stop(t+0.07);
    }

    const sleep = ms => new Promise(r=>setTimeout(r, ms));

    async function type(text, cps){ // time-based for buttery motion
      const start = performance.now(); let i = 0;
      while (i < text.length){
        const elapsed = (performance.now()-start)/1000;
        const target = Math.floor(elapsed*cps);
        if (target > i){
          i = Math.min(target, text.length);
          suffix.textContent = text.slice(0,i);
          caret.style.animation='jiggle 120ms ease-out'; setTimeout(()=>caret.style.animation='',120);
          tap();
        }
        await new Promise(r=>requestAnimationFrame(r));
      }
    }
    async function backspace(n, cps){
      for (let i=0;i<n;i++){
        suffix.textContent = suffix.textContent.slice(0,-1);
        caret.style.animation='jiggle 120ms ease-out'; setTimeout(()=>caret.style.animation='',120);
        tap(); await sleep(1000/cps);
      }
    }

    async function loop(){
      while(true){
        suffix.textContent = '';
        await type('cheat.cc', 7);     // slower
        await sleep(900);
        await backspace('cheat.cc'.length, 7); // slow erase
        await type('ify', 4);          // extra slow
        await sleep(1800);
        await backspace('ify'.length, 9);
        await sleep(500);
      }
    }
    loop();
  })();

  /* ================= OAuth (unchanged) ================= */
  const CLIENT_ID = "ec6dea15d2df46efbb5cc43de67768b3";
  const REDIRECT_URI = "https://quaii.github.io/Plagueify/";
  const SCOPES = "";

  const $ = id => document.getElementById(id);
  const screenA = $('screenA'), screenB = $('screenB');
  const statusA = $('statusA'), statusB = $('statusB');
  const btnLogin = $('btn-login'), btnCopy = $('btn-copy'), tokenBox = $('tokenBox');

  const rand = (len=64)=>{const c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";const b=crypto.getRandomValues(new Uint8Array(len));return Array.from(b,x=>c[x%c.length]).join("")};
  const sha256 = async s => crypto.subtle.digest("SHA-256", new TextEncoder().encode(s));
  const b64url = buf => btoa(String.fromCharCode(...new Uint8Array(buf))).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_");

  const go = w => (w==="A" ? (screenA.classList.remove("hide"),screenB.classList.add("hide")) : (screenA.classList.add("hide"),screenB.classList.remove("hide")));
  function setToken(t){ tokenBox.value=t; tokenBox.addEventListener("focus",()=>tokenBox.select(),{once:true}); tokenBox.addEventListener("click",()=>tokenBox.select()); }
  async function robustCopy(text){
    try { await navigator.clipboard.writeText(text); return true; }
    catch {
      const ta=document.createElement("textarea"); ta.value=text; ta.style.position="fixed"; ta.style.opacity="0";
      document.body.appendChild(ta); ta.focus(); ta.select();
      let ok=false; try{ ok=document.execCommand("copy"); }catch{} document.body.removeChild(ta); return ok;
    }
  }
  async function autoCopyWithGestureFallback(text){
    if (await robustCopy(text)) { statusB.textContent="Copied!"; statusB.classList.remove("err"); statusB.classList.add("ok"); return; }
    statusB.textContent="Tap anywhere or press a key to copy…";
    const once = async () => {
      window.removeEventListener("pointerdown", once);
      window.removeEventListener("keydown", once);
      const ok = await robustCopy(text);
      statusB.textContent = ok ? "Copied!" : "Copy failed. Use Manual Copy.";
      statusB.classList.toggle("ok", ok);
      statusB.classList.toggle("err", !ok);
    };
    window.addEventListener("pointerdown", once, {once:true});
    window.addEventListener("keydown", once, {once:true});
  }

  document.getElementById('btn-login').addEventListener('click', async ()=>{
    const verifier = rand(64); const challenge = b64url(await sha256(verifier));
    sessionStorage.setItem('pkce_verifier', verifier);
    const state = rand(12); sessionStorage.setItem('state', state);
    const q = new URLSearchParams({response_type:"code",client_id:CLIENT_ID,redirect_uri:REDIRECT_URI,scope:SCOPES,code_challenge_method:"S256",code_challenge:challenge,state});
    location.href = "https://accounts.spotify.com/authorize?" + q.toString();
  });

  (async function handleReturn(){
    const qs = new URLSearchParams(location.search);
    if (qs.get("error")) { statusA.textContent="Authorization cancelled."; history.replaceState({}, "", REDIRECT_URI); return; }
    const code = qs.get("code"), state = qs.get("state"); if (!code) return;
    const stored = sessionStorage.getItem("state"); sessionStorage.removeItem("state");
    if (!state || state !== stored) { statusA.textContent="State mismatch. Try again."; history.replaceState({}, "", REDIRECT_URI); return; }

    try {
      const verifier = sessionStorage.getItem("pkce_verifier") || ""; sessionStorage.removeItem("pkce_verifier");
      const body = new URLSearchParams({grant_type:"authorization_code",code,redirect_uri:REDIRECT_URI,client_id:CLIENT_ID,code_verifier:verifier});
      const r = await fetch("https://accounts.spotify.com/api/token", {method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
      const tok = await r.json(); if (!r.ok) throw new Error(JSON.stringify(tok));
      const rt = tok.refresh_token || ""; if (!rt) throw new Error("No refresh_token returned.");
      setToken(rt); go("B"); await autoCopyWithGestureFallback(rt);
    } catch (e) {
      statusA.textContent="Token exchange failed. Please try again."; console.error(e);
    } finally { history.replaceState({}, "", REDIRECT_URI); }
  })();

  document.getElementById('btn-copy')?.addEventListener('click', async ()=>{
    const ok = await robustCopy(tokenBox.value);
    statusB.textContent = ok ? "Copied!" : "Copy failed. Select the field and copy.";
    statusB.classList.toggle("ok", ok);
    statusB.classList.toggle("err", !ok);
  });
});
</script>
</body>
</html>
